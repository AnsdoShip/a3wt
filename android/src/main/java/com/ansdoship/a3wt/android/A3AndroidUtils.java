package com.ansdoship.a3wt.android;

import android.annotation.SuppressLint;
import android.content.ClipData;
import android.content.ClipDescription;
import android.content.ClipboardManager;
import android.content.Context;
import android.content.res.AssetManager;
import android.content.res.Resources;
import android.graphics.*;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.util.DisplayMetrics;
import android.view.InputDevice;
import android.view.MotionEvent;
import android.view.KeyEvent;
import android.view.PointerIcon;
import com.ansdoship.a3wt.app.A3Clipboard;
import com.ansdoship.a3wt.graphics.*;
import com.ansdoship.a3wt.input.A3InputListener;
import pl.droidsonroids.gif.GifDrawable;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;

import static com.ansdoship.a3wt.util.A3Preconditions.checkArgNotEmpty;
import static com.ansdoship.a3wt.util.A3Preconditions.checkArgNotNull;

public class A3AndroidUtils {

    private A3AndroidUtils(){}

    /**
     * Returns a drawable object associated with a particular resource ID.
     * <p>
     * Starting in {@link Build.VERSION_CODES#LOLLIPOP}, the
     * returned drawable will be styled for the specified Context's theme.
     *
     * @param id The desired resource identifier, as generated by the aapt tool.
     *           This integer encodes the package, type, and resource entry.
     *           The value 0 is an invalid identifier.
     * @return Drawable An object that can be used to draw this resource.
     */
    @SuppressLint("UseCompatLoadingForDrawables")
    public static Drawable getDrawable(final Context context, final int id) {
        checkArgNotNull(context, "context");
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            return context.getDrawable(id);
        } else {
            return context.getResources().getDrawable(id);
        }
    }

    public static Bitmap copyBitmap(final Bitmap source) {
        checkArgNotNull(source, "source");
        return source.copy(source.getConfig(), source.isMutable());
    }

    public static Bitmap copyBitmap(final Bitmap source, final Bitmap.Config config) {
        checkArgNotNull(source, "source");
        return source.copy(config, source.isMutable());
    }

    public static int getDisplayWidth(final Resources resources) {
        checkArgNotNull(resources, "resources");
        final DisplayMetrics metrics = resources.getDisplayMetrics();
        return metrics.widthPixels;
    }

    public static int getDisplayHeight(final Resources resources) {
        checkArgNotNull(resources, "resources");
        final DisplayMetrics metrics = resources.getDisplayMetrics();
        return metrics.heightPixels;
    }

    public static Paint.Join strokeJoin2PaintStrokeJoin(final int join) {
        switch (join) {
            case A3Graphics.Join.MITER:
                return Paint.Join.MITER;
            case A3Graphics.Join.ROUND:
                return Paint.Join.ROUND;
            case A3Graphics.Join.BEVEL:
                return Paint.Join.BEVEL;
            default:
                return null;
        }
    }

    public static Paint.Cap strokeCap2PaintStrokeCap(final int cap) {
        switch (cap) {
            case A3Graphics.Cap.BUTT:
                return Paint.Cap.BUTT;
            case A3Graphics.Cap.ROUND:
                return Paint.Cap.ROUND;
            case A3Graphics.Cap.SQUARE:
                return Paint.Cap.SQUARE;
            default:
                return null;
        }
    }

    public static int paintStrokeJoin2StrokeJoin(final Paint.Join join) {
        switch (join) {
            case MITER:
                return A3Graphics.Join.MITER;
            case ROUND:
                return A3Graphics.Join.ROUND;
            case BEVEL:
                return A3Graphics.Join.BEVEL;
            default:
                return -1;
        }
    }

    public static int paintStrokeCap2StrokeCap(final Paint.Cap cap) {
        switch (cap) {
            case BUTT:
                return A3Graphics.Cap.BUTT;
            case ROUND:
                return A3Graphics.Cap.ROUND;
            case SQUARE:
                return A3Graphics.Cap.SQUARE;
            default:
                return -1;
        }
    }

    public static int typefaceStyle2FontStyle(final int style) {
        switch (style) {
            case Typeface.NORMAL:
                return A3Font.Style.NORMAL;
            case Typeface.BOLD:
                return A3Font.Style.BOLD;
            case Typeface.ITALIC:
                return A3Font.Style.ITALIC;
            case Typeface.BOLD_ITALIC:
                return A3Font.Style.BOLD_ITALIC;
            default:
                return -1;
        }
    }

    public static int fontStyle2TypefaceStyle(final int style) {
        switch (style) {
            case A3Font.Style.NORMAL:
                return Typeface.NORMAL;
            case A3Font.Style.BOLD:
                return Typeface.BOLD;
            case A3Font.Style.ITALIC:
                return Typeface.ITALIC;
            case A3Font.Style.BOLD_ITALIC:
                return Typeface.BOLD_ITALIC;
            default:
                return -1;
        }
    }

    public static Paint.Style style2PaintStyle(final int style) {
        switch (style) {
            case A3Graphics.Style.STROKE:
                return Paint.Style.STROKE;
            case A3Graphics.Style.FILL:
                return Paint.Style.FILL;
            default:
                return null;
        }
    }

    public static int paintStyle2Style(final Paint.Style style) {
        switch (style) {
            case STROKE:
                return A3Graphics.Style.STROKE;
            case FILL:
                return A3Graphics.Style.FILL;
            default:
                return -1;
        }
    }

    public static boolean deleteSharedPreferences(final Context context, final String name) {
        checkArgNotNull(context, "context");
        checkArgNotEmpty(name, "name");
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            return context.deleteSharedPreferences(name);
        } else {
            context.getSharedPreferences(name, Context.MODE_PRIVATE).edit().clear().commit();
            return new File(new File(context.getApplicationInfo().dataDir, "shared_prefs"), name + ".xml").delete();
        }
    }

    public static File getSharedPreferencesDir(final Context context) {
        checkArgNotNull(context, "context");
        return new File(context.getApplicationInfo().dataDir, "shared_prefs");
    }

    public static Typeface readTypeface(final AssetManager assets, final String asset) throws IOException {
        checkArgNotNull(assets, "assets");
        checkArgNotEmpty(asset, "asset");
        final Typeface typeface;
        try {
            typeface = Typeface.createFromAsset(assets, asset);
        }
        catch (RuntimeException e) {
            throw new IOException(e);
        }
        return typeface;
    }

    public static Typeface readTypeface(final File input) throws IOException {
        checkArgNotNull(input, "input");
        final Typeface typeface;
        try {
            typeface = Typeface.createFromFile(input);
        }
        catch (RuntimeException e) {
            throw new IOException(e);
        }
        return typeface;
    }

    public static boolean isExternalStorageWriteable() {
        return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());
    }

    public static boolean isExternalStorageReadable() {
        return isExternalStorageWriteable() || Environment.MEDIA_MOUNTED_READ_ONLY.equals(Environment.getExternalStorageState());
    }

    public static File getStorageDir() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            return Environment.getStorageDirectory();
        }
        else {
            return isExternalStorageWriteable() ? Environment.getExternalStorageDirectory() : Environment.getDataDirectory();
        }
    }

    public static int buttonState2Button(final int buttonState) {
        if (buttonState == 0 || (buttonState & MotionEvent.BUTTON_PRIMARY) != 0) return A3InputListener.Button.LEFT;
        else if ((buttonState & MotionEvent.BUTTON_SECONDARY) != 0) return A3InputListener.Button.RIGHT;
        else if ((buttonState & MotionEvent.BUTTON_TERTIARY) != 0) return A3InputListener.Button.MIDDLE;
        else return -1;
    }

    public static int motionEventButton2Button(final int button) {
        switch (button) {
            case MotionEvent.BUTTON_PRIMARY:
                return A3InputListener.Button.LEFT;
            case MotionEvent.BUTTON_SECONDARY:
                return A3InputListener.Button.RIGHT;
            case MotionEvent.BUTTON_TERTIARY:
                return A3InputListener.Button.MIDDLE;
            default:
                return -1;
        }
    }

    public static int button2MotionEventButton(final int button) {
        switch (button) {
            case A3InputListener.Button.LEFT:
                return MotionEvent.BUTTON_PRIMARY;
            case A3InputListener.Button.RIGHT:
                return MotionEvent.BUTTON_SECONDARY;
            case A3InputListener.Button.MIDDLE:
                return MotionEvent.BUTTON_TERTIARY;
            default:
                return -1;
        }
    }

    public static boolean commonOnTouchEvent(final List<A3InputListener> listeners, final MotionEvent event) {
        checkArgNotNull(listeners, "listeners");
        checkArgNotNull(event, "event");
        boolean downResult = false;
        boolean moveResult = false;
        boolean upResult = false;
        final int pointerIndex = event.getPointerCount() - 1;
        final float x = event.getX(pointerIndex);
        final float y = event.getY(pointerIndex);
        final int buttonState = event.getButtonState();
        for (final A3InputListener listener : listeners) {
            switch (event.getActionMasked()) {
                case MotionEvent.ACTION_BUTTON_PRESS:
                case MotionEvent.ACTION_DOWN:
                case MotionEvent.ACTION_POINTER_DOWN:
                    if (!downResult) downResult = listener.pointerDown(x, y, pointerIndex, buttonState2Button(buttonState));
                    break;
                case MotionEvent.ACTION_MOVE:
                    if (!moveResult) moveResult = listener.pointerDragged(x, y, pointerIndex);
                    break;
                case MotionEvent.ACTION_BUTTON_RELEASE:
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_POINTER_UP:
                    if (!upResult) upResult = listener.pointerUp(x, y, pointerIndex, buttonState2Button(buttonState));
                    break;
            }
        }
        return downResult || moveResult || upResult;
    }

    public static boolean commonOnHoverEvent(final List<A3InputListener> listeners, final MotionEvent event) {
        checkArgNotNull(listeners, "listeners");
        checkArgNotNull(event, "event");
        boolean enterResult = false;
        boolean moveResult = false;
        boolean exitResult = false;
        final float x = event.getX();
        final float y = event.getY();
        for (final A3InputListener listener : listeners) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_HOVER_ENTER:
                    if (!enterResult) enterResult = listener.mouseEntered(x, y);
                    break;
                case MotionEvent.ACTION_HOVER_MOVE:
                    if (!moveResult) moveResult = listener.mouseMoved(x, y);
                    break;
                case MotionEvent.ACTION_HOVER_EXIT:
                    if (!exitResult) exitResult = listener.mouseExited(x, y);
                    break;
            }
        }
        return enterResult || moveResult || exitResult;
    }

    public static int getScreenWidth(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().widthPixels;
    }

    public static int getScreenHeight(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().heightPixels;
    }

    public static int getPPI(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().densityDpi;
    }

    public static float getDensity(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().density;
    }

    public static float getScaledDensity(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().scaledDensity;
    }

    public static void putPlainTextToClipboard(final ClipboardManager manager, final CharSequence plainText) {
        checkArgNotNull(manager, "manager");
        checkArgNotNull(plainText, "plainText");
        manager.setPrimaryClip(ClipData.newPlainText(null, plainText));
    }

    public static void putPlainTextToClipboard(final Clipboard clipboard, final CharSequence plainText) {
        checkArgNotNull(clipboard, "clipboard");
        checkArgNotNull(plainText, "plainText");
        clipboard.setPrimaryClip(ClipData.newPlainText(null, plainText));
    }

    public static CharSequence getPlainTextFromClipboard(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return null;
        final ClipData clipData = manager.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) return null;
        final StringBuilder builder = new StringBuilder();
        CharSequence text;
        final int itemCount = clipData.getItemCount();
        for (int i = 0; i < itemCount; i ++) {
            text = clipData.getItemAt(i).getText();
            if (text != null) {
                builder.append(text);
                if (i + 1 < itemCount) builder.append('\n');
            }
        }
        return builder;
    }

    public static CharSequence getPlainTextFromClipboard(final Clipboard clipboard) {
        checkArgNotNull(clipboard, "clipboard");
        if (!clipboard.hasPrimaryClip()) return null;
        final ClipData clipData = clipboard.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) return null;
        final StringBuilder builder = new StringBuilder();
        CharSequence text;
        final int itemCount = clipData.getItemCount();
        for (int i = 0; i < itemCount; i ++) {
            text = clipData.getItemAt(i).getText();
            if (text != null) {
                builder.append(text);
                if (i + 1 < itemCount) builder.append('\n');
            }
        }
        return builder;
    }

    public static void putHTMLTextToClipboard(final ClipboardManager manager, final String HTMLText) {
        checkArgNotNull(manager, "manager");
        checkArgNotNull(HTMLText, "HTMLText");
        manager.setPrimaryClip(ClipData.newHtmlText(null, HTMLText, HTMLText));
    }

    public static void putHTMLTextToClipboard(final Clipboard clipboard, final String HTMLText) {
        checkArgNotNull(clipboard, "clipboard");
        checkArgNotNull(HTMLText, "HTMLText");
        clipboard.setPrimaryClip(ClipData.newHtmlText(null, HTMLText, HTMLText));
    }

    public static String getHTMLTextFromClipboard(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return null;
        final ClipData clipData = manager.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML)) return null;
        final StringBuilder builder = new StringBuilder();
        String text;
        final int itemCount = clipData.getItemCount();
        for (int i = 0; i < itemCount; i ++) {
            text = clipData.getItemAt(i).getHtmlText();
            if (text != null) {
                builder.append(text);
                if (i + 1 < itemCount) builder.append('\n');
            }
        }
        return builder.toString();
    }

    public static String getHTMLTextFromClipboard(final Clipboard clipboard) {
        checkArgNotNull(clipboard, "clipboard");
        if (!clipboard.hasPrimaryClip()) return null;
        final ClipData clipData = clipboard.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML)) return null;
        final StringBuilder builder = new StringBuilder();
        String text;
        final int itemCount = clipData.getItemCount();
        for (int i = 0; i < itemCount; i ++) {
            text = clipData.getItemAt(i).getHtmlText();
            if (text != null) {
                builder.append(text);
                if (i + 1 < itemCount) builder.append('\n');
            }
        }
        return builder.toString();
    }

    public static void putURIsToClipboard(final ClipboardManager manager, final URI[] uris) {
        checkArgNotNull(manager, "manager");
        checkArgNotNull(uris, "uris");
        if (uris.length > 0) {
            final ClipData clipData = ClipData.newRawUri(null, Uri.parse(Uri.decode(uris[0].toString())));
            for (int i = 1; i < uris.length; i ++) {
                clipData.addItem(new ClipData.Item(Uri.parse(uris[i].toString())));
            }
            manager.setPrimaryClip(clipData);
        }
        else manager.setPrimaryClip(ClipData.newPlainText(null, ""));
    }

    public static void putURIsToClipboard(final Clipboard clipboard, final URI[] uris) {
        checkArgNotNull(clipboard, "clipboard");
        checkArgNotNull(uris, "uris");
        if (uris.length > 0) {
            final ClipData clipData = ClipData.newRawUri(null, Uri.parse(Uri.decode(uris[0].toString())));
            for (int i = 1; i < uris.length; i ++) {
                clipData.addItem(new ClipData.Item(Uri.parse(uris[i].toString())));
            }
            clipboard.setPrimaryClip(clipData);
        }
        else clipboard.setPrimaryClip(ClipData.newPlainText(null, ""));
    }

    public static URI[] getURIsFromClipboard(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return null;
        final ClipData clipData = manager.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return null;
        final List<URI> uris = new ArrayList<>();
        Uri uri;
        for (int i = 0; i < clipData.getItemCount(); i ++) {
            uri = clipData.getItemAt(i).getUri();
            if (uri != null) uris.add(URI.create(uri.toString()));
        }
        return uris.toArray(new URI[0]);
    }

    public static URI[] getURIsFromClipboard(final Clipboard clipboard) {
        checkArgNotNull(clipboard, "clipboard");
        if (!clipboard.hasPrimaryClip()) return null;
        final ClipData clipData = clipboard.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return null;
        final List<URI> uris = new ArrayList<>();
        Uri uri;
        for (int i = 0; i < clipData.getItemCount(); i ++) {
            uri = clipData.getItemAt(i).getUri();
            if (uri != null) uris.add(URI.create(uri.toString()));
        }
        return uris.toArray(new URI[0]);
    }

    public static void putUrisToClipboard(final ClipboardManager manager, final Uri[] uris) {
        checkArgNotNull(manager, "manager");
        checkArgNotNull(uris, "uris");
        if (uris.length > 0) {
            final ClipData clipData = ClipData.newRawUri(null, uris[0]);
            for (int i = 1; i < uris.length; i ++) {
                clipData.addItem(new ClipData.Item(uris[i]));
            }
            manager.setPrimaryClip(clipData);
        }
        else manager.setPrimaryClip(ClipData.newPlainText(null, ""));
    }

    public static void putUrisToClipboard(final Clipboard clipboard, final Uri[] uris) {
        checkArgNotNull(clipboard, "clipboard");
        checkArgNotNull(uris, "uris");
        if (uris.length > 0) {
            final ClipData clipData = ClipData.newRawUri(null, uris[0]);
            for (int i = 1; i < uris.length; i ++) {
                clipData.addItem(new ClipData.Item(uris[i]));
            }
            clipboard.setPrimaryClip(clipData);
        }
        else clipboard.setPrimaryClip(ClipData.newPlainText(null, ""));
    }

    public static Uri[] getUrisFromClipboard(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return null;
        final ClipData clipData = manager.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return null;
        final List<Uri> uris = new ArrayList<>();
        Uri uri;
        for (int i = 0; i < clipData.getItemCount(); i ++) {
            uri = clipData.getItemAt(i).getUri();
            if (uri != null) uris.add(uri);
        }
        return uris.toArray(new Uri[0]);
    }

    public static Uri[] getUrisFromClipboard(final Clipboard clipboard) {
        checkArgNotNull(clipboard, "clipboard");
        if (!clipboard.hasPrimaryClip()) return null;
        final ClipData clipData = clipboard.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return null;
        final List<Uri> uris = new ArrayList<>();
        Uri uri;
        for (int i = 0; i < clipData.getItemCount(); i ++) {
            uri = clipData.getItemAt(i).getUri();
            if (uri != null) uris.add(uri);
        }
        return uris.toArray(new Uri[0]);
    }

    public static int getClipboardContentType(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return -1;
        final ClipData clipData = manager.getPrimaryClip();
        final ClipDescription description = clipData.getDescription();
        if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML)) return A3Clipboard.ContentType.HTML_TEXT;
        else if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) return A3Clipboard.ContentType.PLAIN_TEXT;
        else if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return A3Clipboard.ContentType.URI_LIST;
        else return -1;
    }

    public static int getClipboardContentType(final Clipboard clipboard) {
        checkArgNotNull(clipboard, "clipboard");
        if (!clipboard.hasPrimaryClip()) return -1;
        final ClipData clipData = clipboard.getPrimaryClip();
        final ClipDescription description = clipData.getDescription();
        if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML)) return A3Clipboard.ContentType.HTML_TEXT;
        else if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) return A3Clipboard.ContentType.PLAIN_TEXT;
        else if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return A3Clipboard.ContentType.URI_LIST;
        else return -1;
    }

    public static boolean commonOnKeyEvent(final List<A3InputListener> listeners, final KeyEvent event) {
        checkArgNotNull(listeners, "listeners");
        checkArgNotNull(event, "event");
        boolean downResult = false;
        boolean upResult = false;
        final int keyCode = event.getKeyCode();
        for (A3InputListener listener : listeners) {
            switch (event.getAction()) {
                case KeyEvent.ACTION_DOWN:
                    if (!downResult) downResult = listener.keyDown(keyCode, A3InputListener.KeyLocation.STANDARD);
                    break;
                case KeyEvent.ACTION_UP:
                    if (!upResult) upResult = listener.keyUp(keyCode, A3InputListener.KeyLocation.STANDARD);
                    break;
            }
        }
        return downResult || upResult;
    }

    public static boolean commonOnMouseWheelMotion(final List<A3InputListener> listeners, final MotionEvent event) {
        checkArgNotNull(listeners, "listeners");
        checkArgNotNull(event, "event");
        if ((event.getSource() & InputDevice.SOURCE_MOUSE) == 0) return false;
        boolean result = false;
        for (final A3InputListener listener : listeners) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_SCROLL:
                    if (!result) result = listener.mouseWheelScrolled(event.getAxisValue(MotionEvent.AXIS_VSCROLL), A3InputListener.ScrollType.UNIT);
                    break;
            }
        }
        return result;
    }

    public static Bitmap getBitmap(final Bitmap source, final Bitmap.Config config) {
        checkArgNotNull(source, "source");
        if (config == null || source.getConfig().equals(config)) return source;
        else {
            final Bitmap result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), config);
            final Canvas canvas = new Canvas(result);
            canvas.drawBitmap(source, 0, 0, null);
            if (!source.isRecycled()) source.recycle();
            return result;
        }
    }

    public static Bitmap getAlignedBitmap(final Bitmap source, final int alignX, final int alignY, final int width, final int height) {
        checkArgNotNull(source, "source");
        if (source.getWidth() == width && source.getHeight() == height) return source;
        final Bitmap result = Bitmap.createBitmap(width, height, source.getConfig());
        final Canvas canvas = new Canvas(source);
        canvas.drawBitmap(source, alignX, alignY, null);
        if (!source.isRecycled()) source.recycle();
        return result;
    }

    public static A3FramedImage gifDrawable2FramedImage(final GifDrawable drawable, final Bitmap.Config config) {
        checkArgNotNull(drawable, "drawable");
        try {
            AndroidA3Image[] frames = new AndroidA3Image[drawable.getNumberOfFrames()];
            for (int i = 0; i < frames.length; i ++) {
                frames[i] = new AndroidA3Image(getBitmap(drawable.seekToFrameAndGet(i), config), drawable.getFrameDuration(i), 0, 0);
            }
            A3FramedImage result = new DefaultA3FramedImage(frames);
            result.setLooping(drawable.getLoopCount());
            return result;
        }
        finally {
            if (!drawable.isRecycled()) drawable.recycle();
        }
    }

    public static int cursorType2PointerIconType(int type) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            switch (type) {
                case A3Cursor.Type.GONE:
                    return PointerIcon.TYPE_NULL;
                case A3Cursor.Type.ARROW:
                    return PointerIcon.TYPE_ARROW;
                case A3Cursor.Type.CROSSHAIR:
                    return PointerIcon.TYPE_CROSSHAIR;
                case A3Cursor.Type.IBEAM:
                    return PointerIcon.TYPE_TEXT;
                case A3Cursor.Type.WAIT:
                    return PointerIcon.TYPE_WAIT;
                case A3Cursor.Type.RESIZE_NS:

                case A3Cursor.Type.RESIZE_N://FIXME
                case A3Cursor.Type.RESIZE_S://FIXME

                    return PointerIcon.TYPE_VERTICAL_DOUBLE_ARROW;
                case A3Cursor.Type.RESIZE_WE:

                case A3Cursor.Type.RESIZE_W://FIXME
                case A3Cursor.Type.RESIZE_E://FIXME

                    return PointerIcon.TYPE_HORIZONTAL_DOUBLE_ARROW;
                case A3Cursor.Type.RESIZE_NWSE:

                case A3Cursor.Type.RESIZE_NW://FIXME
                case A3Cursor.Type.RESIZE_SE://FIXME

                    return PointerIcon.TYPE_TOP_LEFT_DIAGONAL_DOUBLE_ARROW;
                case A3Cursor.Type.RESIZE_NESW:

                case A3Cursor.Type.RESIZE_NE://FIXME
                case A3Cursor.Type.RESIZE_SW://FIXME

                    return PointerIcon.TYPE_TOP_RIGHT_DIAGONAL_DOUBLE_ARROW;
                case A3Cursor.Type.HAND:
                    return PointerIcon.TYPE_HAND;
                case A3Cursor.Type.MOVE:
                    return PointerIcon.TYPE_ALL_SCROLL;
                case A3Cursor.Type.GRAB:
                    return PointerIcon.TYPE_GRAB;
                case A3Cursor.Type.GRABBING:
                    return PointerIcon.TYPE_GRABBING;
                case A3Cursor.Type.HELP:
                    return PointerIcon.TYPE_HELP;
                case A3Cursor.Type.NO:
                    return PointerIcon.TYPE_NO_DROP;
                case A3Cursor.Type.ZOOM_IN:
                    return PointerIcon.TYPE_ZOOM_IN;
                case A3Cursor.Type.ZOOM_OUT:
                    return PointerIcon.TYPE_ZOOM_OUT;
                default:
                    return -1;
            }
        }
        else {
            return -1;
        }
    }

    public static int pointerIconType2CursorType(int type) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            switch (type) {
                case PointerIcon.TYPE_NULL:
                    return A3Cursor.Type.GONE;
                case PointerIcon.TYPE_ARROW:
                    return A3Cursor.Type.ARROW;
                case PointerIcon.TYPE_CROSSHAIR:
                    return A3Cursor.Type.CROSSHAIR;
                case PointerIcon.TYPE_TEXT:
                    return A3Cursor.Type.IBEAM;
                case PointerIcon.TYPE_WAIT:
                    return A3Cursor.Type.WAIT;
                case PointerIcon.TYPE_VERTICAL_DOUBLE_ARROW:
                    return A3Cursor.Type.RESIZE_NS;
                case PointerIcon.TYPE_HORIZONTAL_DOUBLE_ARROW:
                    return A3Cursor.Type.RESIZE_WE;
                case PointerIcon.TYPE_TOP_LEFT_DIAGONAL_DOUBLE_ARROW:
                    return A3Cursor.Type.RESIZE_NWSE;
                case PointerIcon.TYPE_TOP_RIGHT_DIAGONAL_DOUBLE_ARROW:
                    return A3Cursor.Type.RESIZE_NESW;
                case PointerIcon.TYPE_HAND:
                    return A3Cursor.Type.HAND;
                case PointerIcon.TYPE_ALL_SCROLL:
                    return A3Cursor.Type.MOVE;
                case PointerIcon.TYPE_GRAB:
                    return A3Cursor.Type.GRAB;
                case PointerIcon.TYPE_GRABBING:
                    return A3Cursor.Type.GRABBING;
                case PointerIcon.TYPE_HELP:
                    return A3Cursor.Type.HELP;
                case PointerIcon.TYPE_NO_DROP:
                    return A3Cursor.Type.NO;
                case PointerIcon.TYPE_ZOOM_IN:
                    return A3Cursor.Type.ZOOM_IN;
                case PointerIcon.TYPE_ZOOM_OUT:
                    return A3Cursor.Type.ZOOM_OUT;
                default:
                    return -1;
            }
        }
        else {
            return -1;
        }
    }

    /**
     * Calculates the number of times the line from (x0,y0) to (x1,y1)
     * crosses the ray extending to the right from (px,py).
     * If the point lies on the line, then no crossings are recorded.
     * +1 is returned for a crossing where the Y coordinate is increasing
     * -1 is returned for a crossing where the Y coordinate is decreasing
     */
    public static int pointCrossingsForLine(final double px, final double py,
                                            final double x0, final double y0,
                                            final double x1, final double y1) {
        if (py <  y0 && py <  y1) return 0;
        if (py >= y0 && py >= y1) return 0;
        if (px >= x0 && px >= x1) return 0;
        if (px <  x0 && px <  x1) return (y0 < y1) ? 1 : -1;
        final double xintercept = x0 + (py - y0) * (x1 - x0) / (y1 - y0);
        if (px >= xintercept) return 0;
        return (y0 < y1) ? 1 : -1;
    }

    /**
     * Calculates the number of times the quad from (x0,y0) to (x1,y1)
     * crosses the ray extending to the right from (px,py).
     * If the point lies on a part of the curve,
     * then no crossings are counted for that intersection.
     * the level parameter should be 0 at the top-level call and will count
     * up for each recursion level to prevent infinite recursion
     * +1 is added for each crossing where the Y coordinate is increasing
     * -1 is added for each crossing where the Y coordinate is decreasing
     */
    public static int pointCrossingsForQuad(final double px, final double py,
                                            final double x0, final double y0,
                                            double xc, double yc,
                                            final double x1, final double y1, final int level)
    {
        if (py <  y0 && py <  yc && py <  y1) return 0;
        if (py >= y0 && py >= yc && py >= y1) return 0;
        // Note y0 could equal y1...
        if (px >= x0 && px >= xc && px >= x1) return 0;
        if (px <  x0 && px <  xc && px <  x1) {
            if (py >= y0) {
                if (py < y1) return 1;
            } else {
                // py < y0
                if (py >= y1) return -1;
            }
            // py outside of y01 range, and/or y0==y1
            return 0;
        }
        // double precision only has 52 bits of mantissa
        if (level > 52) return pointCrossingsForLine(px, py, x0, y0, x1, y1);
        final double x0c = (x0 + xc) / 2;
        final double y0c = (y0 + yc) / 2;
        final double xc1 = (xc + x1) / 2;
        final double yc1 = (yc + y1) / 2;
        xc = (x0c + xc1) / 2;
        yc = (y0c + yc1) / 2;
        if (Double.isNaN(xc) || Double.isNaN(yc)) {
            // [xy]c are NaN if any of [xy]0c or [xy]c1 are NaN
            // [xy]0c or [xy]c1 are NaN if any of [xy][0c1] are NaN
            // These values are also NaN if opposing infinities are added
            return 0;
        }
        return (pointCrossingsForQuad(px, py,
                x0, y0, x0c, y0c, xc, yc,
                level+1) +
                pointCrossingsForQuad(px, py,
                        xc, yc, xc1, yc1, x1, y1,
                        level+1));
    }

    /**
     * Calculates the number of times the cubic from (x0,y0) to (x1,y1)
     * crosses the ray extending to the right from (px,py).
     * If the point lies on a part of the curve,
     * then no crossings are counted for that intersection.
     * the level parameter should be 0 at the top-level call and will count
     * up for each recursion level to prevent infinite recursion
     * +1 is added for each crossing where the Y coordinate is increasing
     * -1 is added for each crossing where the Y coordinate is decreasing
     */
    public static int pointCrossingsForCubic(final double px, final double py,
                                             final double x0, final double y0,
                                             double xc0, double yc0,
                                             double xc1, double yc1,
                                             final double x1, final double y1, final int level)
    {
        if (py <  y0 && py <  yc0 && py <  yc1 && py <  y1) return 0;
        if (py >= y0 && py >= yc0 && py >= yc1 && py >= y1) return 0;
        // Note y0 could equal yc0...
        if (px >= x0 && px >= xc0 && px >= xc1 && px >= x1) return 0;
        if (px <  x0 && px <  xc0 && px <  xc1 && px <  x1) {
            if (py >= y0) {
                if (py < y1) return 1;
            } else {
                // py < y0
                if (py >= y1) return -1;
            }
            // py outside of y01 range, and/or y0==yc0
            return 0;
        }
        // double precision only has 52 bits of mantissa
        if (level > 52) return pointCrossingsForLine(px, py, x0, y0, x1, y1);
        double xmid = (xc0 + xc1) / 2;
        double ymid = (yc0 + yc1) / 2;
        xc0 = (x0 + xc0) / 2;
        yc0 = (y0 + yc0) / 2;
        xc1 = (xc1 + x1) / 2;
        yc1 = (yc1 + y1) / 2;
        double xc0m = (xc0 + xmid) / 2;
        double yc0m = (yc0 + ymid) / 2;
        double xmc1 = (xmid + xc1) / 2;
        double ymc1 = (ymid + yc1) / 2;
        xmid = (xc0m + xmc1) / 2;
        ymid = (yc0m + ymc1) / 2;
        if (Double.isNaN(xmid) || Double.isNaN(ymid)) {
            // [xy]mid are NaN if any of [xy]c0m or [xy]mc1 are NaN
            // [xy]c0m or [xy]mc1 are NaN if any of [xy][c][01] are NaN
            // These values are also NaN if opposing infinities are added
            return 0;
        }
        return (pointCrossingsForCubic(px, py,
                x0, y0, xc0, yc0,
                xc0m, yc0m, xmid, ymid, level+1) +
                pointCrossingsForCubic(px, py,
                        xmid, ymid, xmc1, ymc1,
                        xc1, yc1, x1, y1, level+1));
    }

    /**
     * The rectangle intersection test counts the number of times
     * that the path crosses through the shadow that the rectangle
     * projects to the right towards (x => +INFINITY).
     *
     * During processing of the path it actually counts every time
     * the path crosses either or both of the top and bottom edges
     * of that shadow.  If the path enters from the top, the count
     * is incremented.  If it then exits back through the top, the
     * same way it came in, the count is decremented and there is
     * no impact on the winding count.  If, instead, the path exits
     * out the bottom, then the count is incremented again and a
     * full pass through the shadow is indicated by the winding count
     * having been incremented by 2.
     *
     * Thus, the winding count that it accumulates is actually double
     * the real winding count.  Since the path is continuous, the
     * final answer should be a multiple of 2, otherwise there is a
     * logic error somewhere.
     *
     * If the path ever has a direct hit on the rectangle, then a
     * special value is returned.  This special value terminates
     * all ongoing accumulation on up through the call chain and
     * ends up getting returned to the calling function which can
     * then produce an answer directly.  For intersection tests,
     * the answer is always "true" if the path intersects the
     * rectangle.  For containment tests, the answer is always
     * "false" if the path intersects the rectangle.  Thus, no
     * further processing is ever needed if an intersection occurs.
     */
    public static final int RECT_INTERSECTS = 0x80000000;

    /**
     * Accumulate the number of times the line crosses the shadow
     * extending to the right of the rectangle.  See the comment
     * for the RECT_INTERSECTS constant for more complete details.
     */
    public static int rectCrossingsForLine(int crossings,
                                           final double rxmin, final double rymin,
                                           final double rxmax, final double rymax,
                                           final double x0, final double y0,
                                           final double x1, final double y1)
    {
        if (y0 >= rymax && y1 >= rymax) return crossings;
        if (y0 <= rymin && y1 <= rymin) return crossings;
        if (x0 <= rxmin && x1 <= rxmin) return crossings;
        if (x0 >= rxmax && x1 >= rxmax) {
            // Line is entirely to the right of the rect
            // and the vertical ranges of the two overlap by a non-empty amount
            // Thus, this line segment is partially in the "right-shadow"
            // Path may have done a complete crossing
            // Or path may have entered or exited the right-shadow
            if (y0 < y1) {
                // y-increasing line segment...
                // We know that y0 < rymax and y1 > rymin
                if (y0 <= rymin) crossings++;
                if (y1 >= rymax) crossings++;
            } else if (y1 < y0) {
                // y-decreasing line segment...
                // We know that y1 < rymax and y0 > rymin
                if (y1 <= rymin) crossings--;
                if (y0 >= rymax) crossings--;
            }
            return crossings;
        }
        // Remaining case:
        // Both x and y ranges overlap by a non-empty amount
        // First do trivial INTERSECTS rejection of the cases
        // where one of the endpoints is inside the rectangle.
        if ((x0 > rxmin && x0 < rxmax && y0 > rymin && y0 < rymax) ||
                (x1 > rxmin && x1 < rxmax && y1 > rymin && y1 < rymax))
        {
            return RECT_INTERSECTS;
        }
        // Otherwise calculate the y intercepts and see where
        // they fall with respect to the rectangle
        double xi0 = x0;
        if (y0 < rymin) {
            xi0 += ((rymin - y0) * (x1 - x0) / (y1 - y0));
        } else if (y0 > rymax) {
            xi0 += ((rymax - y0) * (x1 - x0) / (y1 - y0));
        }
        double xi1 = x1;
        if (y1 < rymin) {
            xi1 += ((rymin - y1) * (x0 - x1) / (y0 - y1));
        } else if (y1 > rymax) {
            xi1 += ((rymax - y1) * (x0 - x1) / (y0 - y1));
        }
        if (xi0 <= rxmin && xi1 <= rxmin) return crossings;
        if (xi0 >= rxmax && xi1 >= rxmax) {
            if (y0 < y1) {
                // y-increasing line segment...
                // We know that y0 < rymax and y1 > rymin
                if (y0 <= rymin) crossings++;
                if (y1 >= rymax) crossings++;
            } else if (y1 < y0) {
                // y-decreasing line segment...
                // We know that y1 < rymax and y0 > rymin
                if (y1 <= rymin) crossings--;
                if (y0 >= rymax) crossings--;
            }
            return crossings;
        }
        return RECT_INTERSECTS;
    }

    /**
     * Accumulate the number of times the quad crosses the shadow
     * extending to the right of the rectangle.  See the comment
     * for the RECT_INTERSECTS constant for more complete details.
     */
    public static int rectCrossingsForQuad(int crossings,
                                           final double rxmin, final double rymin,
                                           final double rxmax, final double rymax,
                                           final double x0, final double y0,
                                           double xc, double yc,
                                           final double x1, final double y1,
                                           final int level)
    {
        if (y0 >= rymax && yc >= rymax && y1 >= rymax) return crossings;
        if (y0 <= rymin && yc <= rymin && y1 <= rymin) return crossings;
        if (x0 <= rxmin && xc <= rxmin && x1 <= rxmin) return crossings;
        if (x0 >= rxmax && xc >= rxmax && x1 >= rxmax) {
            // Quad is entirely to the right of the rect
            // and the vertical range of the 3 Y coordinates of the quad
            // overlaps the vertical range of the rect by a non-empty amount
            // We now judge the crossings solely based on the line segment
            // connecting the endpoints of the quad.
            // Note that we may have 0, 1, or 2 crossings as the control
            // point may be causing the Y range intersection while the
            // two endpoints are entirely above or below.
            if (y0 < y1) {
                // y-increasing line segment...
                if (y0 <= rymin && y1 >  rymin) crossings++;
                if (y0 <  rymax && y1 >= rymax) crossings++;
            } else if (y1 < y0) {
                // y-decreasing line segment...
                if (y1 <= rymin && y0 >  rymin) crossings--;
                if (y1 <  rymax && y0 >= rymax) crossings--;
            }
            return crossings;
        }
        // The intersection of ranges is more complicated
        // First do trivial INTERSECTS rejection of the cases
        // where one of the endpoints is inside the rectangle.
        if ((x0 < rxmax && x0 > rxmin && y0 < rymax && y0 > rymin) ||
                (x1 < rxmax && x1 > rxmin && y1 < rymax && y1 > rymin))
        {
            return RECT_INTERSECTS;
        }
        // Otherwise, subdivide and look for one of the cases above.
        // double precision only has 52 bits of mantissa
        if (level > 52) {
            return rectCrossingsForLine(crossings,
                    rxmin, rymin, rxmax, rymax,
                    x0, y0, x1, y1);
        }
        double x0c = (x0 + xc) / 2;
        double y0c = (y0 + yc) / 2;
        double xc1 = (xc + x1) / 2;
        double yc1 = (yc + y1) / 2;
        xc = (x0c + xc1) / 2;
        yc = (y0c + yc1) / 2;
        if (Double.isNaN(xc) || Double.isNaN(yc)) {
            // [xy]c are NaN if any of [xy]0c or [xy]c1 are NaN
            // [xy]0c or [xy]c1 are NaN if any of [xy][0c1] are NaN
            // These values are also NaN if opposing infinities are added
            return 0;
        }
        crossings = rectCrossingsForQuad(crossings,
                rxmin, rymin, rxmax, rymax,
                x0, y0, x0c, y0c, xc, yc,
                level+1);
        if (crossings != RECT_INTERSECTS) {
            crossings = rectCrossingsForQuad(crossings,
                    rxmin, rymin, rxmax, rymax,
                    xc, yc, xc1, yc1, x1, y1,
                    level+1);
        }
        return crossings;
    }

    /**
     * Accumulate the number of times the cubic crosses the shadow
     * extending to the right of the rectangle.  See the comment
     * for the RECT_INTERSECTS constant for more complete details.
     */
    public static int rectCrossingsForCubic(int crossings,
                                            final double rxmin, final double rymin,
                                            final double rxmax, final double rymax,
                                            final double x0,  final double y0,
                                            double xc0, double yc0,
                                            double xc1, double yc1,
                                            final double x1,  final double y1,
                                            final int level)
    {
        if (y0 >= rymax && yc0 >= rymax && yc1 >= rymax && y1 >= rymax) {
            return crossings;
        }
        if (y0 <= rymin && yc0 <= rymin && yc1 <= rymin && y1 <= rymin) {
            return crossings;
        }
        if (x0 <= rxmin && xc0 <= rxmin && xc1 <= rxmin && x1 <= rxmin) {
            return crossings;
        }
        if (x0 >= rxmax && xc0 >= rxmax && xc1 >= rxmax && x1 >= rxmax) {
            // Cubic is entirely to the right of the rect
            // and the vertical range of the 4 Y coordinates of the cubic
            // overlaps the vertical range of the rect by a non-empty amount
            // We now judge the crossings solely based on the line segment
            // connecting the endpoints of the cubic.
            // Note that we may have 0, 1, or 2 crossings as the control
            // points may be causing the Y range intersection while the
            // two endpoints are entirely above or below.
            if (y0 < y1) {
                // y-increasing line segment...
                if (y0 <= rymin && y1 >  rymin) crossings++;
                if (y0 <  rymax && y1 >= rymax) crossings++;
            } else if (y1 < y0) {
                // y-decreasing line segment...
                if (y1 <= rymin && y0 >  rymin) crossings--;
                if (y1 <  rymax && y0 >= rymax) crossings--;
            }
            return crossings;
        }
        // The intersection of ranges is more complicated
        // First do trivial INTERSECTS rejection of the cases
        // where one of the endpoints is inside the rectangle.
        if ((x0 > rxmin && x0 < rxmax && y0 > rymin && y0 < rymax) ||
                (x1 > rxmin && x1 < rxmax && y1 > rymin && y1 < rymax))
        {
            return RECT_INTERSECTS;
        }
        // Otherwise, subdivide and look for one of the cases above.
        // double precision only has 52 bits of mantissa
        if (level > 52) {
            return rectCrossingsForLine(crossings,
                    rxmin, rymin, rxmax, rymax,
                    x0, y0, x1, y1);
        }
        double xmid = (xc0 + xc1) / 2;
        double ymid = (yc0 + yc1) / 2;
        xc0 = (x0 + xc0) / 2;
        yc0 = (y0 + yc0) / 2;
        xc1 = (xc1 + x1) / 2;
        yc1 = (yc1 + y1) / 2;
        double xc0m = (xc0 + xmid) / 2;
        double yc0m = (yc0 + ymid) / 2;
        double xmc1 = (xmid + xc1) / 2;
        double ymc1 = (ymid + yc1) / 2;
        xmid = (xc0m + xmc1) / 2;
        ymid = (yc0m + ymc1) / 2;
        if (Double.isNaN(xmid) || Double.isNaN(ymid)) {
            // [xy]mid are NaN if any of [xy]c0m or [xy]mc1 are NaN
            // [xy]c0m or [xy]mc1 are NaN if any of [xy][c][01] are NaN
            // These values are also NaN if opposing infinities are added
            return 0;
        }
        crossings = rectCrossingsForCubic(crossings,
                rxmin, rymin, rxmax, rymax,
                x0, y0, xc0, yc0,
                xc0m, yc0m, xmid, ymid, level+1);
        if (crossings != RECT_INTERSECTS) {
            crossings = rectCrossingsForCubic(crossings,
                    rxmin, rymin, rxmax, rymax,
                    xmid, ymid, xmc1, ymc1,
                    xc1, yc1, x1, y1, level+1);
        }
        return crossings;
    }
    /*
     * Normalizes the specified angle into the range -180 to 180.
     */
    public static double normalizeDegrees(double angle) {
        if (angle > 180.0) {
            if (angle <= (180.0 + 360.0)) {
                angle = angle - 360.0;
            } else {
                angle = Math.IEEEremainder(angle, 360.0);
                // IEEEremainder can return -180 here for some input values...
                if (angle == -180.0) {
                    angle = 180.0;
                }
            }
        } else if (angle <= -180.0) {
            if (angle > (-180.0 - 360.0)) {
                angle = angle + 360.0;
            } else {
                angle = Math.IEEEremainder(angle, 360.0);
                // IEEEremainder can return -180 here for some input values...
                if (angle == -180.0) {
                    angle = 180.0;
                }
            }
        }
        return angle;
    }

    /**
     * Returns an indicator of where the specified point
     * {@code (px,py)} lies with respect to the line segment from
     * {@code (x1,y1)} to {@code (x2,y2)}.
     * The return value can be either 1, -1, or 0 and indicates
     * in which direction the specified line must pivot around its
     * first end point, {@code (x1,y1)}, in order to point at the
     * specified point {@code (px,py)}.
     * <p>A return value of 1 indicates that the line segment must
     * turn in the direction that takes the positive X axis towards
     * the negative Y axis.  In the default coordinate system used by
     * Java 2D, this direction is counterclockwise.
     * <p>A return value of -1 indicates that the line segment must
     * turn in the direction that takes the positive X axis towards
     * the positive Y axis.  In the default coordinate system, this
     * direction is clockwise.
     * <p>A return value of 0 indicates that the point lies
     * exactly on the line segment.  Note that an indicator value
     * of 0 is rare and not useful for determining collinearity
     * because of floating point rounding issues.
     * <p>If the point is colinear with the line segment, but
     * not between the end points, then the value will be -1 if the point
     * lies "beyond {@code (x1,y1)}" or 1 if the point lies
     * "beyond {@code (x2,y2)}".
     *
     * @param x1 the X coordinate of the start point of the
     *           specified line segment
     * @param y1 the Y coordinate of the start point of the
     *           specified line segment
     * @param x2 the X coordinate of the end point of the
     *           specified line segment
     * @param y2 the Y coordinate of the end point of the
     *           specified line segment
     * @param px the X coordinate of the specified point to be
     *           compared with the specified line segment
     * @param py the Y coordinate of the specified point to be
     *           compared with the specified line segment
     * @return an integer that indicates the position of the third specified
     *                  coordinates with respect to the line segment formed
     *                  by the first two specified coordinates.
     */
    public static int relativeCCW(final double x1, final double y1,
                                  double x2, double y2,
                                  double px, double py)
    {
        x2 -= x1;
        y2 -= y1;
        px -= x1;
        py -= y1;
        double ccw = px * y2 - py * x2;
        if (ccw == 0.0) {
            // The point is colinear, classify based on which side of
            // the segment the point falls on.  We can calculate a
            // relative value using the projection of px,py onto the
            // segment - a negative value indicates the point projects
            // outside of the segment in the direction of the particular
            // endpoint used as the origin for the projection.
            ccw = px * x2 + py * y2;
            if (ccw > 0.0) {
                // Reverse the projection to be relative to the original x2,y2
                // x2 and y2 are simply negated.
                // px and py need to have (x2 - x1) or (y2 - y1) subtracted
                //    from them (based on the original values)
                // Since we really want to get a positive answer when the
                //    point is "beyond (x2,y2)", then we want to calculate
                //    the inverse anyway - thus we leave x2 & y2 negated.
                px -= x2;
                py -= y2;
                ccw = px * x2 + py * y2;
                if (ccw < 0.0) {
                    ccw = 0.0;
                }
            }
        }
        return Double.compare(ccw, 0.0);
    }

    /**
     * The bitmask that indicates that a point lies to the left of
     * this {@code RectF}.
     */
    public static final int OUT_LEFT = 1;

    /**
     * The bitmask that indicates that a point lies above
     * this {@code RectF}.
     */
    public static final int OUT_TOP = 2;

    /**
     * The bitmask that indicates that a point lies to the right of
     * this {@code RectF}.
     */
    public static final int OUT_RIGHT = 4;

    /**
     * The bitmask that indicates that a point lies below
     * this {@code RectF}.
     */
    public static final int OUT_BOTTOM = 8;

    /**
     * Tests if the specified line segment intersects the interior of this
     * {@code RectF}.
     *
     * @param x1 the X coordinate of the start point of the specified
     *           line segment
     * @param y1 the Y coordinate of the start point of the specified
     *           line segment
     * @param x2 the X coordinate of the end point of the specified
     *           line segment
     * @param y2 the Y coordinate of the end point of the specified
     *           line segment
     * @return {@code true} if the specified line segment intersects
     * the interior of this {@code RectF}; {@code false}
     * otherwise.
     */
    public static boolean intersectsLine(final RectF rectF, double x1, double y1, double x2, double y2) {
        int out1, out2;
        if ((out2 = outcode(rectF, x2, y2)) == 0) {
            return true;
        }
        while ((out1 = outcode(rectF, x1, y1)) != 0) {
            if ((out1 & out2) != 0) {
                return false;
            }
            if ((out1 & (OUT_LEFT | OUT_RIGHT)) != 0) {
                double x = rectF.left;
                if ((out1 & OUT_RIGHT) != 0) {
                    x += rectF.width();
                }
                y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);
                x1 = x;
            } else {
                double y = rectF.top;
                if ((out1 & OUT_BOTTOM) != 0) {
                    y += rectF.height();
                }
                x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);
                y1 = y;
            }
        }
        return true;
    }

    public static int outcode(final RectF rectF, double x, double y) {
        checkArgNotNull(rectF, "rectF");
        /*
         * Note on casts to double below.  If the arithmetic of
         * x+w or y+h is done in float, then some bits may be
         * lost if the binary exponents of x/y and w/h are not
         * similar.  By converting to double before the addition
         * we force the addition to be carried out in double to
         * avoid rounding error in the comparison.
         */
        int out = 0;
        if (rectF.width() <= 0) {
            out |= OUT_LEFT | OUT_RIGHT;
        } else if (x < rectF.left) {
            out |= OUT_LEFT;
        } else if (x > rectF.left + (double) rectF.width()) {
            out |= OUT_RIGHT;
        }
        if (rectF.height() <= 0) {
            out |= OUT_TOP | OUT_BOTTOM;
        } else if (y < rectF.top) {
            out |= OUT_TOP;
        } else if (y > rectF.top + (double) rectF.height()) {
            out |= OUT_BOTTOM;
        }
        return out;
    }

    public static int bitmapConfig2ImageType(final Bitmap.Config config) {
        switch (config) {
            case ARGB_8888:
                return A3Image.Type.ARGB_8888;
            case RGB_565:
                return A3Image.Type.RGB_565;
            default:
                return -1;
        }
    }

    public static Bitmap.Config imageType2BitmapConfig(final int type) {
        switch (type) {
            case A3Image.Type.ARGB_8888:
                return Bitmap.Config.ARGB_8888;
            case A3Image.Type.RGB_565:
                return Bitmap.Config.RGB_565;
            default:
                return null;
        }
    }

}

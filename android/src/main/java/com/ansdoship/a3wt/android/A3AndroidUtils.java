package com.ansdoship.a3wt.android;

import android.annotation.SuppressLint;
import android.content.ClipData;
import android.content.ClipDescription;
import android.content.ClipboardManager;
import android.content.Context;
import android.content.res.AssetManager;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Paint;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.util.DisplayMetrics;
import android.view.MotionEvent;
import android.view.KeyEvent;
import com.ansdoship.a3wt.app.A3Clipboard;
import com.ansdoship.a3wt.graphics.A3Font;
import com.ansdoship.a3wt.graphics.A3Graphics;
import com.ansdoship.a3wt.input.A3InputListener;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;

import static com.ansdoship.a3wt.util.A3Asserts.checkArgNotEmpty;
import static com.ansdoship.a3wt.util.A3Asserts.checkArgNotNull;

public class A3AndroidUtils {

    private A3AndroidUtils(){}

    /**
     * Returns a drawable object associated with a particular resource ID.
     * <p>
     * Starting in {@link Build.VERSION_CODES#LOLLIPOP}, the
     * returned drawable will be styled for the specified Context's theme.
     *
     * @param id The desired resource identifier, as generated by the aapt tool.
     *           This integer encodes the package, type, and resource entry.
     *           The value 0 is an invalid identifier.
     * @return Drawable An object that can be used to draw this resource.
     */
    @SuppressLint("UseCompatLoadingForDrawables")
    public static Drawable getDrawable(final Context context, final int id) {
        checkArgNotNull(context, "context");
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            return context.getDrawable(id);
        } else {
            return context.getResources().getDrawable(id);
        }
    }

    public static Bitmap copyBitmap(final Bitmap source) {
        checkArgNotNull(source, "source");
        return source.copy(source.getConfig(), source.isMutable());
    }

    public static int getDisplayWidth(final Resources resources) {
        checkArgNotNull(resources, "resources");
        final DisplayMetrics metrics = resources.getDisplayMetrics();
        return metrics.widthPixels;
    }

    public static int getDisplayHeight(final Resources resources) {
        checkArgNotNull(resources, "resources");
        final DisplayMetrics metrics = resources.getDisplayMetrics();
        return metrics.heightPixels;
    }

    public static Paint.Join strokeJoin2PaintStrokeJoin(final int join) {
        switch (join) {
            case A3Graphics.Join.MITER: default:
                return Paint.Join.MITER;
            case A3Graphics.Join.ROUND:
                return Paint.Join.ROUND;
            case A3Graphics.Join.BEVEL:
                return Paint.Join.BEVEL;
        }
    }

    public static Paint.Cap strokeCap2PaintStrokeCap(final int cap) {
        switch (cap) {
            case A3Graphics.Cap.BUTT: default:
                return Paint.Cap.BUTT;
            case A3Graphics.Cap.ROUND:
                return Paint.Cap.ROUND;
            case A3Graphics.Cap.SQUARE:
                return Paint.Cap.SQUARE;
        }
    }

    public static int paintStrokeJoin2StrokeJoin(final Paint.Join join) {
        switch (join) {
            case MITER: default:
                return A3Graphics.Join.MITER;
            case ROUND:
                return A3Graphics.Join.ROUND;
            case BEVEL:
                return A3Graphics.Join.BEVEL;
        }
    }

    public static int paintStrokeCap2StrokeCap(final Paint.Cap cap) {
        switch (cap) {
            case BUTT: default:
                return A3Graphics.Cap.BUTT;
            case ROUND:
                return A3Graphics.Cap.ROUND;
            case SQUARE:
                return A3Graphics.Cap.SQUARE;
        }
    }

    public static int typefaceStyle2FontStyle(final int style) {
        switch (style) {
            case Typeface.NORMAL: default:
                return A3Font.Style.NORMAL;
            case Typeface.BOLD:
                return A3Font.Style.BOLD;
            case Typeface.ITALIC:
                return A3Font.Style.ITALIC;
            case Typeface.BOLD_ITALIC:
                return A3Font.Style.BOLD_ITALIC;
        }
    }

    public static int fontStyle2TypefaceStyle(final int style) {
        switch (style) {
            case A3Font.Style.NORMAL: default:
                return Typeface.NORMAL;
            case A3Font.Style.BOLD:
                return Typeface.BOLD;
            case A3Font.Style.ITALIC:
                return Typeface.ITALIC;
            case A3Font.Style.BOLD_ITALIC:
                return Typeface.BOLD_ITALIC;
        }
    }

    public static Paint.Style style2PaintStyle(final int style) {
        switch (style) {
            case A3Graphics.Style.STROKE: default:
                return Paint.Style.STROKE;
            case A3Graphics.Style.FILL:
                return Paint.Style.FILL;
        }
    }

    public static int paintStyle2Style(final Paint.Style style) {
        switch (style) {
            case STROKE:
                return A3Graphics.Style.STROKE;
            case FILL:
                return A3Graphics.Style.FILL;
            default:
                return -1;
        }
    }

    public static boolean deleteSharedPreferences(final Context context, final String name) {
        checkArgNotNull(context, "context");
        checkArgNotEmpty(name, "name");
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            return context.deleteSharedPreferences(name);
        } else {
            context.getSharedPreferences(name, Context.MODE_PRIVATE).edit().clear().commit();
            return new File(new File(context.getApplicationInfo().dataDir, "shared_prefs"), name + ".xml").delete();
        }
    }

    public static File getSharedPreferencesDir(final Context context) {
        checkArgNotNull(context, "context");
        return new File(context.getApplicationInfo().dataDir, "shared_prefs");
    }

    public static Typeface readTypeface(final AssetManager assets, final String asset) throws IOException {
        checkArgNotNull(assets, "assets");
        checkArgNotEmpty(asset, "asset");
        final Typeface typeface;
        try {
            typeface = Typeface.createFromAsset(assets, asset);
        }
        catch (RuntimeException e) {
            throw new IOException(e);
        }
        return typeface;
    }

    public static Typeface readTypeface(final File input) throws IOException {
        checkArgNotNull(input, "input");
        final Typeface typeface;
        try {
            typeface = Typeface.createFromFile(input);
        }
        catch (RuntimeException e) {
            throw new IOException(e);
        }
        return typeface;
    }

    public static boolean isExternalStorageWriteable() {
        return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());
    }

    public static boolean isExternalStorageReadable() {
        return isExternalStorageWriteable() || Environment.MEDIA_MOUNTED_READ_ONLY.equals(Environment.getExternalStorageState());
    }

    public static File getStorageDir() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            return Environment.getStorageDirectory();
        }
        else {
            return isExternalStorageWriteable() ? Environment.getExternalStorageDirectory() : Environment.getDataDirectory();
        }
    }

    public static boolean commonOnTouchEvent(final List<A3InputListener> listeners, final MotionEvent event) {
        checkArgNotNull(listeners, "listeners");
        checkArgNotNull(event, "event");
        boolean downResult = false;
        boolean moveResult = false;
        boolean upResult = false;
        final int pointerIndex = event.getPointerCount() - 1;
        final float x = event.getX(pointerIndex);
        final float y = event.getY(pointerIndex);
        for (A3InputListener listener : listeners) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                case MotionEvent.ACTION_POINTER_DOWN:
                    if (!downResult) downResult = listener.pointerDown(x, y, pointerIndex, A3InputListener.Button.LEFT);
                    break;
                case MotionEvent.ACTION_MOVE:
                    if (!moveResult) moveResult = listener.pointerDragged(x, y, pointerIndex);
                    break;
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_POINTER_UP:
                    if (!upResult) upResult = listener.pointerUp(x, y, pointerIndex, A3InputListener.Button.LEFT);
                    break;
            }
        }
        return downResult || moveResult || upResult;
    }

    public static int getScreenWidth(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().widthPixels;
    }

    public static int getScreenHeight(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().heightPixels;
    }

    public static int getPPI(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().densityDpi;
    }

    public static float getDensity(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().density;
    }

    public static float getScaledDensity(final Resources resources) {
        checkArgNotNull(resources, "resources");
        return resources.getDisplayMetrics().scaledDensity;
    }

    public static void putPlainTextToClipboard(final ClipboardManager manager, final CharSequence plainText) {
        checkArgNotNull(manager, "manager");
        checkArgNotNull(plainText, "plainText");
        manager.setPrimaryClip(ClipData.newPlainText(null, plainText));
    }

    public static CharSequence getPlainTextFromClipboard(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return null;
        final ClipData clipData = manager.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) return null;
        final StringBuilder builder = new StringBuilder();
        CharSequence text;
        final int itemCount = clipData.getItemCount();
        for (int i = 0; i < itemCount; i ++) {
            text = clipData.getItemAt(i).getText();
            if (text != null) {
                builder.append(text);
                if (i + 1 < itemCount) builder.append('\n');
            }
        }
        return builder;
    }

    public static void putHTMLTextToClipboard(final ClipboardManager manager, final String HTMLText) {
        checkArgNotNull(manager, "manager");
        checkArgNotNull(HTMLText, "HTMLText");
        manager.setPrimaryClip(ClipData.newHtmlText(null, HTMLText, HTMLText));
    }

    public static String getHTMLTextFromClipboard(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return null;
        final ClipData clipData = manager.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML)) return null;
        final StringBuilder builder = new StringBuilder();
        String text;
        final int itemCount = clipData.getItemCount();
        for (int i = 0; i < itemCount; i ++) {
            text = clipData.getItemAt(i).getHtmlText();
            if (text != null) {
                builder.append(text);
                if (i + 1 < itemCount) builder.append('\n');
            }
        }
        return builder.toString();
    }

    public static void putURIsToClipboard(final ClipboardManager manager, final URI[] uris) {
        checkArgNotNull(manager, "manager");
        checkArgNotNull(uris, "uris");
        if (uris.length > 0) {
            final ClipData clipData = ClipData.newRawUri(null, Uri.parse(Uri.decode(uris[0].toString())));
            for (int i = 1; i < uris.length; i ++) {
                clipData.addItem(new ClipData.Item(Uri.parse(uris[i].toString())));
            }
            manager.setPrimaryClip(clipData);
        }
        else manager.setPrimaryClip(ClipData.newPlainText(null, ""));
    }

    public static URI[] getURIsFromClipboard(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return null;
        final ClipData clipData = manager.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return null;
        final List<URI> uris = new ArrayList<>();
        Uri uri;
        for (int i = 0; i < clipData.getItemCount(); i ++) {
            uri = clipData.getItemAt(i).getUri();
            if (uri != null) uris.add(URI.create(uri.toString()));
        }
        return uris.toArray(new URI[0]);
    }

    public static void putUrisToClipboard(final ClipboardManager manager, final Uri[] uris) {
        checkArgNotNull(manager, "manager");
        checkArgNotNull(uris, "uris");
        if (uris.length > 0) {
            final ClipData clipData = ClipData.newRawUri(null, uris[0]);
            for (int i = 1; i < uris.length; i ++) {
                clipData.addItem(new ClipData.Item(uris[i]));
            }
            manager.setPrimaryClip(clipData);
        }
        else manager.setPrimaryClip(ClipData.newPlainText(null, ""));
    }

    public static Uri[] getUrisFromClipboard(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return null;
        final ClipData clipData = manager.getPrimaryClip();
        if (!clipData.getDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return null;
        final List<Uri> uris = new ArrayList<>();
        Uri uri;
        for (int i = 0; i < clipData.getItemCount(); i ++) {
            uri = clipData.getItemAt(i).getUri();
            if (uri != null) uris.add(uri);
        }
        return uris.toArray(new Uri[0]);
    }

    public static int getClipboardContentType(final ClipboardManager manager) {
        checkArgNotNull(manager, "manager");
        if (!manager.hasPrimaryClip()) return -1;
        final ClipData clipData = manager.getPrimaryClip();
        final ClipDescription description = clipData.getDescription();
        if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML)) return A3Clipboard.ContentType.HTML_TEXT;
        else if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) return A3Clipboard.ContentType.PLAIN_TEXT;
        else if (description.hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) return A3Clipboard.ContentType.URI_LIST;
        else return -1;
    }

    public static boolean commonOnKeyEvent(final List<A3InputListener> listeners, final KeyEvent event) {
        checkArgNotNull(listeners, "listeners");
        checkArgNotNull(event, "event");
        boolean downResult = false;
        boolean upResult = false;
        final int keyCode = event.getKeyCode();
        for (A3InputListener listener : listeners) {
            switch (event.getAction()) {
                case KeyEvent.ACTION_DOWN:
                    if (!downResult) downResult = listener.keyDown(keyCode, A3InputListener.KeyLocation.STANDARD);
                    break;
                case KeyEvent.ACTION_UP:
                    if (!upResult) upResult = listener.keyUp(keyCode, A3InputListener.KeyLocation.STANDARD);
                    break;
            }
        }
        return downResult || upResult;
    }

}
